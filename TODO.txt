Mutex en map (quizás, con lambda)

Remember to call isRunning before adding tasks
Add params for number of basic tasks on constructor, and add that many threads

handshakeHandlerTask, after handshakeDone, is clearing the buffer. Maybe check contentLength or any other header

Set server callbacks on runtime?

Search for "TODO" to see more tasks


SERVER DATA

-List of Socket+State (HTTP/Handshake pending)
    -> State: Buffer + id of the current protocol part

-List of WebSocketsConnection


SERVER TASKS

-(Maybe just "newClient") New clients
    -> New clients are moved to a new list of thread/protocol state

-HTTP/WebSocket protocol
    -> If protocol is finished and it is HTTP, remove socket
    -> If it is WebSocket, move to connected sockets list

-Read and write WebSocket packets (One per connection)
    -> Write the list of pending packets
    -> If packet sucesfully read, decipher Imasi protocol and create callback task
    -> If socket/packet error/timeout/closed, create closedSocket callback task and remove socket


ACTUAL IMPLEMENTATION
    - acceptClientsTask - 1 thread, always
    - handshakeHandlerTask - N threads, enqueuing himself if pending handshake, taking drom list
    - webSocketManagerTask - N threads, enqueuing himself always


CONNECTIONS:
    - ADD: Protocol task (_connectionMutex)
    - REMOVE: Websocket task (_connectionMutex)
    - WORK WITH CONNECTION: Websocket task (Callback, through WebSocketConnection)


INTERFACES
    - Connection: Send, Ping, Disconnect
    - Server: SendBroadcast, PingAll